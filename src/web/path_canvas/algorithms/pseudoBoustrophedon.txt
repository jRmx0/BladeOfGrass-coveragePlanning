# Boustrophedon Cellular Decomposition - Based on Choset & Pignon 1997

## 1. Main Algorithm

```
FUNCTION GENERATE_BOUSTROPHEDON_CELLS(boundary, obstacles)
    // Generate events from polygons
    events ← CREATE_EVENTS_LIST(boundary, obstacles)
    
    // Sort events by x-coordinate
    SORT_EVENTS_BY_X(events)
    
    // Initialize cell tracking
    cells ← []
    currentCells ← []  // Active cells being built
    
    // Initialize first cell (leftmost region)
    bounds ← COMPUTE_ENVIRONMENT_BOUNDS(boundary, obstacles)
    firstCell ← INITIALIZE_FIRST_CELL(bounds)
    APPEND firstCell TO currentCells
    
    // Process each event in order
    FOR EACH event IN events DO
        PROCESS_EVENT(event, currentCells, cells)
    END FOR
    
    // Finalize remaining cells
    FOR EACH cell IN currentCells DO
        FINALIZE_CELL(cell, bounds.maxX)
        APPEND cell TO cells
    END FOR
    
    RETURN cells
END FUNCTION
```

## 2. Event Generation (Core Algorithm)

```
FUNCTION CREATE_EVENTS_LIST(boundary, obstacles)
    events ← []
    
    // Process boundary polygon
    PROCESS_POLYGON(boundary, events)
    
    // Process each obstacle polygon
    FOR EACH obstacle IN obstacles DO
        PROCESS_POLYGON(obstacle, events)
    END FOR
    
    RETURN events
END FUNCTION

FUNCTION PROCESS_POLYGON(polygon, events)
    // Find leftmost vertex (IN event)
    leftmostIndex ← FIND_LEFTMOST_VERTEX_INDEX(polygon)
    leftmostVertex ← polygon[leftmostIndex]
    
    // Create IN event
    inEvent ← CREATE_EVENT("IN", leftmostVertex.x, leftmostVertex.y)
    inEvent.polygon ← polygon
    inEvent.vertexIndex ← leftmostIndex
    APPEND inEvent TO events
    
    // Find rightmost vertex (OUT event) 
    rightmostIndex ← FIND_RIGHTMOST_VERTEX_INDEX(polygon)
    rightmostVertex ← polygon[rightmostIndex]
    
    // Create OUT event
    outEvent ← CREATE_EVENT("OUT", rightmostVertex.x, rightmostVertex.y)
    outEvent.polygon ← polygon
    outEvent.vertexIndex ← rightmostIndex
    APPEND outEvent TO events
    
    // Create CEILING events (vertices between IN and OUT going clockwise from IN)
    currentIndex ← (leftmostIndex + 1) % LENGTH(polygon)
    WHILE currentIndex != rightmostIndex DO
        vertex ← polygon[currentIndex]
        ceilingEvent ← CREATE_EVENT("CEILING", vertex.x, vertex.y)
        ceilingEvent.polygon ← polygon
        ceilingEvent.vertexIndex ← currentIndex
        APPEND ceilingEvent TO events
        currentIndex ← (currentIndex + 1) % LENGTH(polygon)
    END WHILE
    
    // Create FLOOR events (vertices between OUT and IN going clockwise from OUT)
    currentIndex ← (rightmostIndex + 1) % LENGTH(polygon)
    WHILE currentIndex != leftmostIndex DO
        vertex ← polygon[currentIndex]
        floorEvent ← CREATE_EVENT("FLOOR", vertex.x, vertex.y)
        floorEvent.polygon ← polygon
        floorEvent.vertexIndex ← currentIndex
        APPEND floorEvent TO events
        currentIndex ← (currentIndex + 1) % LENGTH(polygon)
    END WHILE
END FUNCTION
```

## 3. Event Processing (Following Choset & Pignon Algorithm)

```
FUNCTION PROCESS_EVENT(event, currentCells, finishedCells)
    SWITCH event.type
        CASE "IN":
            // IN event: One cell splits into two
            // Find cell that contains this event
            containingCell ← FIND_CELL_CONTAINING_POINT(event.y, currentCells)
            
            // Close the containing cell
            CLOSE_CELL_AT_X(containingCell, event.x)
            REMOVE containingCell FROM currentCells
            APPEND containingCell TO finishedCells
            
            // Create two new cells: bottom and top
            bottomCell ← CREATE_BOTTOM_CELL(containingCell, event)
            topCell ← CREATE_TOP_CELL(containingCell, event)
            
            APPEND bottomCell TO currentCells
            APPEND topCell TO currentCells
            
        CASE "OUT":
            // OUT event: Two cells merge into one
            // Find the two cells that will merge
            bottomCell, topCell ← FIND_CELLS_FOR_MERGE(event, currentCells)
            
            // Close both cells
            CLOSE_CELL_AT_X(bottomCell, event.x)
            CLOSE_CELL_AT_X(topCell, event.x)
            REMOVE bottomCell FROM currentCells
            REMOVE topCell FROM currentCells
            APPEND bottomCell TO finishedCells
            APPEND topCell TO finishedCells
            
            // Create merged cell
            mergedCell ← CREATE_MERGED_CELL(bottomCell, topCell, event)
            APPEND mergedCell TO currentCells
            
        CASE "CEILING":
            // CEILING event: Update ceiling of affected cells
            // Simply update the ceiling edge list of affected cells
            affectedCells ← FIND_CELLS_AFFECTED_BY_CEILING(event, currentCells)
            FOR EACH cell IN affectedCells DO
                UPDATE_CELL_CEILING(cell, event)
            END FOR
            
        CASE "FLOOR":
            // FLOOR event: Update floor of affected cells  
            // Simply update the floor edge list of affected cells
            affectedCells ← FIND_CELLS_AFFECTED_BY_FLOOR(event, currentCells)
            FOR EACH cell IN affectedCells DO
                UPDATE_CELL_FLOOR(cell, event)
            END FOR
    END SWITCH
END FUNCTION
```

## 4. Cell Data Structure (Based on Paper)

```
STRUCTURE Cell
    id                  // Unique identifier
    leftBoundary        // x-coordinate where cell starts
    rightBoundary       // x-coordinate where cell ends (set when closed)
    floorEdges          // List of edges forming the floor of the cell
    ceilingEdges        // List of edges forming the ceiling of the cell
    polygon             // Final polygon representation (computed when cell is finalized)
END STRUCTURE

STRUCTURE Event
    type                // "IN", "OUT", "CEILING", "FLOOR"
    x                   // x-coordinate of event
    y                   // y-coordinate of event
    polygon             // Reference to the polygon this event belongs to
    vertexIndex         // Index of vertex in polygon
    floorPointer        // Pointer to edge for floor events
    ceilingPointer      // Pointer to edge for ceiling events
END STRUCTURE

STRUCTURE Edge
    startPoint          // Start point of edge
    endPoint           // End point of edge
END STRUCTURE
```
    
## 5. Cell Creation and Management

```
FUNCTION CREATE_BOTTOM_CELL(parentCell, inEvent)
    bottomCell ← CREATE_NEW_CELL()
    bottomCell.leftBoundary ← inEvent.x
    
    // Floor edges come from parent cell
    bottomCell.floorEdges ← DEEP_COPY(parentCell.floorEdges)
    
    // Ceiling edges come from the obstacle's floor edge (the edge going into the obstacle)
    bottomCell.ceilingEdges ← [GET_OBSTACLE_FLOOR_EDGE(inEvent)]
    
    RETURN bottomCell
END FUNCTION

FUNCTION CREATE_TOP_CELL(parentCell, inEvent)
    topCell ← CREATE_NEW_CELL()
    topCell.leftBoundary ← inEvent.x
    
    // Floor edges come from the obstacle's ceiling edge (the edge coming out of the obstacle)
    topCell.floorEdges ← [GET_OBSTACLE_CEILING_EDGE(inEvent)]
    
    // Ceiling edges come from parent cell
    topCell.ceilingEdges ← DEEP_COPY(parentCell.ceilingEdges)
    
    RETURN topCell
END FUNCTION

FUNCTION CREATE_MERGED_CELL(bottomCell, topCell, outEvent)
    mergedCell ← CREATE_NEW_CELL()
    mergedCell.leftBoundary ← outEvent.x
    
    // Floor comes from bottom cell, ceiling comes from top cell
    mergedCell.floorEdges ← DEEP_COPY(bottomCell.floorEdges)
    mergedCell.ceilingEdges ← DEEP_COPY(topCell.ceilingEdges)
    
    RETURN mergedCell
END FUNCTION

FUNCTION CLOSE_CELL_AT_X(cell, xCoordinate)
    cell.rightBoundary ← xCoordinate
    
    // Convert floor and ceiling edges to final polygon
    FINALIZE_CELL_POLYGON(cell)
END FUNCTION
```

## 6. Cell Finalization and Polygon Generation

```
FUNCTION FINALIZE_CELL_POLYGON(cell)
    vertices ← []
    
    // Start from left boundary
    leftFloorY ← COMPUTE_Y_INTERSECTION(cell.leftBoundary, cell.floorEdges)
    leftCeilingY ← COMPUTE_Y_INTERSECTION(cell.leftBoundary, cell.ceilingEdges)
    
    // Add bottom-left corner
    APPEND {x: cell.leftBoundary, y: leftFloorY} TO vertices
    
    // Add floor edge vertices (left to right)
    floorVertices ← EXTRACT_VERTICES_IN_RANGE(cell.floorEdges, cell.leftBoundary, cell.rightBoundary)
    FOR EACH vertex IN floorVertices DO
        APPEND vertex TO vertices
    END FOR
    
    // Add bottom-right corner
    rightFloorY ← COMPUTE_Y_INTERSECTION(cell.rightBoundary, cell.floorEdges)
    APPEND {x: cell.rightBoundary, y: rightFloorY} TO vertices
    
    // Add top-right corner
    rightCeilingY ← COMPUTE_Y_INTERSECTION(cell.rightBoundary, cell.ceilingEdges)
    APPEND {x: cell.rightBoundary, y: rightCeilingY} TO vertices
    
    // Add ceiling edge vertices (right to left)
    ceilingVertices ← EXTRACT_VERTICES_IN_RANGE(cell.ceilingEdges, cell.rightBoundary, cell.leftBoundary)
    REVERSE(ceilingVertices)
    FOR EACH vertex IN ceilingVertices DO
        APPEND vertex TO vertices
    END FOR
    
    // Add top-left corner
    APPEND {x: cell.leftBoundary, y: leftCeilingY} TO vertices
    
    // Clean up duplicate vertices and ensure proper winding
    cell.polygon ← CLEAN_POLYGON_VERTICES(vertices)
END FUNCTION
```

## 7. Helper Functions

```
FUNCTION FIND_CELL_CONTAINING_POINT(y, currentCells)
    // Find which cell contains the given y-coordinate
    FOR EACH cell IN currentCells DO
        yRange ← GET_CELL_Y_RANGE(cell)
        IF y >= yRange.min AND y <= yRange.max THEN
            RETURN cell
        END IF
    END FOR
    RETURN NULL
END FUNCTION

FUNCTION GET_CELL_Y_RANGE(cell)
    // Get the current y-range of a cell
    floorY ← MINIMUM_Y_OF_EDGES(cell.floorEdges)
    ceilingY ← MAXIMUM_Y_OF_EDGES(cell.ceilingEdges)
    RETURN {min: floorY, max: ceilingY}
END FUNCTION

FUNCTION FIND_CELLS_FOR_MERGE(outEvent, currentCells)
    // Find the two adjacent cells that need to merge at an OUT event
    candidateCells ← []
    
    FOR EACH cell IN currentCells DO
        yRange ← GET_CELL_Y_RANGE(cell)
        // Check if event y-coordinate is at the boundary between cells
        IF ABS(yRange.min - outEvent.y) < EPSILON OR ABS(yRange.max - outEvent.y) < EPSILON THEN
            APPEND cell TO candidateCells
        END IF
    END FOR
    
    // Should find exactly 2 cells
    IF LENGTH(candidateCells) = 2 THEN
        // Determine which is bottom and which is top
        IF GET_CELL_Y_RANGE(candidateCells[0]).min < GET_CELL_Y_RANGE(candidateCells[1]).min THEN
            RETURN candidateCells[0], candidateCells[1]  // bottom, top
        ELSE
            RETURN candidateCells[1], candidateCells[0]  // bottom, top
        END IF
    END IF
    
    ERROR("Could not find exactly 2 cells for merge at OUT event")
END FUNCTION

FUNCTION COMPUTE_Y_INTERSECTION(x, edges)
    // Find y-coordinate where vertical line at x intersects the edge list
    FOR EACH edge IN edges DO
        IF (edge.startPoint.x <= x AND edge.endPoint.x >= x) OR 
           (edge.startPoint.x >= x AND edge.endPoint.x <= x) THEN
            // Linear interpolation
            IF ABS(edge.endPoint.x - edge.startPoint.x) < EPSILON THEN
                // Vertical edge
                RETURN edge.startPoint.y
            ELSE
                t ← (x - edge.startPoint.x) / (edge.endPoint.x - edge.startPoint.x)
                RETURN edge.startPoint.y + t * (edge.endPoint.y - edge.startPoint.y)
            END IF
        END IF
    END FOR
    ERROR("No intersection found")
END FUNCTION

FUNCTION COMPUTE_ENVIRONMENT_BOUNDS(boundary, obstacles)
    allVertices ← GET_ALL_VERTICES(boundary)
    FOR EACH obstacle IN obstacles DO
        APPEND_ALL GET_ALL_VERTICES(obstacle) TO allVertices
    END FOR
    
    minX ← MINIMUM(vertex.x FOR vertex IN allVertices)
    maxX ← MAXIMUM(vertex.x FOR vertex IN allVertices)
    minY ← MINIMUM(vertex.y FOR vertex IN allVertices)
    maxY ← MAXIMUM(vertex.y FOR vertex IN allVertices)
    
    RETURN {minX, maxX, minY, maxY}
END FUNCTION

FUNCTION INITIALIZE_FIRST_CELL(bounds)
    firstCell ← CREATE_NEW_CELL()
    firstCell.leftBoundary ← bounds.minX - EPSILON
    
    // Create artificial boundary edges
    bottomEdge ← CREATE_EDGE({x: bounds.minX, y: bounds.minY}, {x: bounds.maxX, y: bounds.minY})
    topEdge ← CREATE_EDGE({x: bounds.minX, y: bounds.maxY}, {x: bounds.maxX, y: bounds.maxY})
    
    firstCell.floorEdges ← [bottomEdge]
    firstCell.ceilingEdges ← [topEdge]
    
    RETURN firstCell
END FUNCTION

FUNCTION SORT_EVENTS_BY_X(events)
    // Sort events by x-coordinate, with tie-breaking for events at same x
    SORT events BY (event.x, PRIORITY(event.type))
    // Priority: IN=1, CEILING=2, FLOOR=3, OUT=4
END FUNCTION

FUNCTION CREATE_NEW_CELL()
    cell ← NEW Cell()
    cell.id ← GENERATE_UNIQUE_ID()
    cell.floorEdges ← []
    cell.ceilingEdges ← []
    RETURN cell
END FUNCTION
```

## 8. Key Implementation Notes

```
// EPSILON value for numerical precision
EPSILON ← 1e-10

// Event type priorities for sorting
PRIORITY("IN") ← 1      // Process IN events first at same x-coordinate
PRIORITY("CEILING") ← 2 
PRIORITY("FLOOR") ← 3
PRIORITY("OUT") ← 4     // Process OUT events last at same x-coordinate

// The core insight from Choset & Pignon:
// - Cells are regions bounded by floor and ceiling edges
// - IN events split one cell into two cells
// - OUT events merge two cells into one cell  
// - CEILING/FLOOR events simply update the boundary edges of existing cells
// - This naturally creates the minimum number of cells for coverage

// Critical difference from trapezoidal decomposition:
// - Trapezoidal creates new cells at every obstacle vertex
// - Boustrophedon only creates/destroys cells at connectivity changes (IN/OUT events)
// - This results in fewer cells and more efficient coverage paths
```